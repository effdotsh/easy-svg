use serde::Deserialize;
use std::collections::HashMap;
use std::fs;

#[derive(Deserialize)]
struct Config {
    elements: HashMap<String, Element>,
}

#[derive(Deserialize)]
struct Element {
    constructor_params: Vec<Param>,
    fields: HashMap<String, Field>,
}

#[derive(Deserialize)]
struct Param {
    name: String,
    #[serde(rename = "type")]
    param_type: String,
}

#[derive(Deserialize)]
struct Field {
    #[serde(rename = "type")]
    field_type: String,
    from_constructor: Option<bool>,
}

fn main() {
    println!("cargo:rerun-if-changed=svg_elements.yaml");

    let yaml_content =
        fs::read_to_string("svg_elements.yml").expect("Failed to read svg_elements.yaml");
    let config: Config = serde_yaml::from_str(&yaml_content).expect("Failed to parse YAML");

    let mut generated_code = String::new();
    generated_code.push_str(
        r#"// @generated
// This file is automatically generated by build.rs
use crate::color::Color;
use serde::{Deserialize, Serialize};
use std::fmt::Display;"#,
    );

    generated_code.push_str(generate_shape_enum(&config).as_str());

    for (element_name, element) in &config.elements {
        generated_code.push_str(&generate_struct(element_name, element));
        generated_code.push_str(&generate_impl(element_name, element));
        generated_code.push_str(&generate_to_string(element_name, element));
        generated_code.push_str(&generate_shape_from(element_name));
    }

    fs::write("src/generated.rs", format_rust_code(&generated_code)).unwrap();
}

fn generate_shape_from(element_name: &String) -> String {
    let struct_name = capitalize(element_name);
    format!(
        "
impl From<{}> for Shape {{
    fn from({}: {}) -> Self {{
        Self::{}({})
    }}
}}",
        struct_name, element_name, struct_name, struct_name, element_name
    )
}

fn generate_shape_enum(config: &Config) -> String {
    let mut generated_code = String::new();

    generated_code.push_str(&format!(
        "
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = \"type\")]
pub enum Shape {{
    {}
}}",
        &config
            .elements
            .iter()
            .map(|(element_name, _)| {
                let struct_name = capitalize(element_name);
                format!("{}({})", struct_name, struct_name)
            })
            .collect::<Vec<_>>()
            .join(", ")
    ));

    generated_code.push_str(&format!(
        "
impl Display for Shape {{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {{
        let str = match self {{
            {}
        }};
        write!(f, \"{{}}\", str)
    }}
}}
",
        &config
            .elements
            .iter()
            .map(|(element_name, _)| {
                let struct_name = capitalize(element_name);
                format!(
                    "Shape::{}({}) => {}.to_string()",
                    struct_name, element_name, element_name
                )
            })
            .collect::<Vec<_>>()
            .join(", ")
    ));

    generated_code
}

fn generate_struct(name: &str, element: &Element) -> String {
    let struct_name = capitalize(name);
    let mut fields = Vec::new();

    for (field_name, field) in &element.fields {
        fields.push(format!("    pub {}: {},", field_name, field.field_type));
    }

    format!(
        "#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct {} {{\n{}\n}}\n\n",
        struct_name,
        fields.join("\n")
    )
}

fn generate_to_string(name: &str, element: &Element) -> String {
    let struct_name = capitalize(name);
    let mut generated_code = String::new();
    generated_code.push_str(format!("impl Display for {} {{\n", struct_name).as_ref());
    generated_code
        .push_str("    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n");

    let required_parameters = element
        .constructor_params
        .iter()
        .map(|param| format!("{}=\"{{}}\" ", param.name))
        .collect::<String>();

    let required_arguments = element
        .constructor_params
        .iter()
        .map(|param| format!("self.{},", param.name))
        .collect::<String>();

    generated_code.push_str(&format!(
        "let mut svg =format!(r#\"<{} {}\"#,\n{});",
        name, required_parameters, required_arguments
    ));

    for (field_name, field) in &element.fields {
        if let Some(from_constructor) = field.from_constructor
            && from_constructor
        {
            continue;
        }
        generated_code.push_str(&format!(
            "if let Some({}) = &self.{} {{",
            field_name, field_name
        ));
        generated_code.push_str(&format!(
            "svg.push_str(&format!(r#\" {}=\"{{}}\"\"#, {}));",
            field_name, field_name
        ));
        generated_code.push_str("}")
    }
    generated_code.push_str(r#"svg.push_str("/>");"#);

    generated_code.push_str(r#"write!(f, "{}", svg)"#);
    generated_code.push_str("}}");
    generated_code
}
fn generate_impl(name: &str, element: &Element) -> String {
    let struct_name = capitalize(name);
    let mut code = format!("impl {} {{\n", struct_name);

    code.push_str(&generate_constructor(element));

    for (field_name, field) in &element.fields {
        if !field.from_constructor.unwrap_or(false) {
            code.push_str(&generate_builder_method(field_name, field));
        }
    }

    code.push_str("}\n\n");
    code
}

fn generate_constructor(element: &Element) -> String {
    let params: Vec<String> = element
        .constructor_params
        .iter()
        .map(|p| format!("{}: {}", p.name, p.param_type))
        .collect();

    let mut field_assignments = Vec::new();
    for (field_name, field) in &element.fields {
        if field.from_constructor.unwrap_or(false) {
            field_assignments.push(format!("            {},", field_name));
        } else {
            field_assignments.push(format!("            {}: None,", field_name));
        }
    }

    format!(
        "    pub fn new({}) -> Self {{\n        Self {{\n{}\n        }}\n    }}\n\n",
        params.join(", "),
        field_assignments.join("\n")
    )
}

fn generate_builder_method(field_name: &str, field: &Field) -> String {
    // Extract inner type from Option<T>
    let param_type = if field.field_type.starts_with("Option<") {
        &field.field_type[7..field.field_type.len() - 1]
    } else {
        &field.field_type
    };

    format!(
        "    pub fn {}(mut self, value: {}) -> Self {{\n        self.{} = Some(value);\n        self\n    }}\n\n",
        field_name, param_type, field_name
    )
}

fn capitalize(s: &str) -> String {
    let mut chars = s.chars();
    match chars.next() {
        None => String::new(),
        Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
    }
}
fn format_rust_code(code: &str) -> String {
    match syn::parse_file(code) {
        Ok(syntax_tree) => prettyplease::unparse(&syntax_tree),
        Err(e) => {
            println!("cargo:warning=Failed to parse generated code: {}", e);
            println!("cargo:warning=Using unformatted code");
            code.to_string()
        }
    }
}
